zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
# for(i in 2:(steps + 1)){
#
#
# }
Q
Qfull
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 2
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, QFull)
all_locs[, i] = alpha_next
}
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 2
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
all_locs
# Plot locations
locs = all_locs[c(1, 3), ]
plots(locs[1, ], locs[2, ])
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
lines(locs[1, ], locs[2, ])
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.01
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 1
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
lines(locs[1, ], locs[2, ])
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.8
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
lines(locs[1, ], locs[2, ])
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.5
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.6
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.7
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.75
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.75
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.8
sigma_proc = 1
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
lines(locs[1, ], locs[2, ])
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.8
sigma_proc = 3
delta = 1 # Time step
steps = 20
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
lines(locs[1, ], locs[2, ])
# Format the data for fitting with crawl
t(locs)
# Format the data for fitting with crawl
sim_dat = data.frame(t(locs))
sim_dat$time = 1:21
# Format the data for fitting with crawl
sim_dat = data.frame(t(locs))
sim_dat$time = 1:21
sim_dat
# Format the data for fitting with crawl
sim_dat = data.frame(t(locs))
sim_dat$time = 1:21
colnames(sim_dat) = c("x", "y", "time")
?crwMLE
library(crawl)
fit_sim = crwMLE(mov.mod=~1, data=sim_dat, Time.name="time", coord=c('x', 'y'))
library(crawl)
initial = list(a=c(20, 0, 20, 0))
fit_sim = crwMLE(mov.mod=~1, data=sim_dat, Time.name="time", coord=c('x', 'y'), initial.state = initial)
# Format the data for fitting with crawl
sim_dat = data.frame(t(locs))
sim_dat$time = 1:21
colnames(sim_dat) = c("x", "y", "time")
sim_dat
initial
library(crawl)
initial = list(a=c(20, 0, 20, 0))
fit_sim = crwMLE(mov.mod=~1, data=sim_dat, Time.name="time", coord=c('x', 'y'), initial.state = initial, drift=FALSE)
library(crawl)
initial = list(a=c(20, 0, 20, 0),
P=diag(c(10000^2,5400^2,10000^2,5400^2)))
fit_sim = crwMLE(mov.mod=~1, data=sim_dat, Time.name="time", coord=c('x', 'y'), initial.state = initial, drift=FALSE)
summary(fit_sim)
fit_sim
exp(0.622)
exp(0.228)
exp(-0.598)
exp(1.055)
predTime = 1:21
predObj <- crwPredict(object.crwFit=sim,
predTime,
speedEst=TRUE,
flat=TRUE)
predTime = 1:21
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
crwPredictPlot(predObj, "map")
predTime = seq(1, 21, len=100)
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
crwPredictPlot(predObj, "map")
crwPredict?
?crwPredict
predObj <- crwPredict(object.crwFit=fit1,
predTime,
speedEst=TRUE,
flat=TRUE,
getUseAvail=TRUE)
predObj <- crwPredict(object.crwFit=fit1,
predTime,
speedEst=TRUE,
flat=TRUE,
getUseAvail=TRUE)
predObj <- crwPredict(object.crwFit=fit1,
predTime,
speedEst=TRUE,
flat=TRUE)
predTime = seq(1, 21, len=100)
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
predTime = seq(1, 21, len=50)
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
predTime = seq(1, 21, len=50)
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE,
getUseAvail=TRUE)
predTime = seq(1, 21, len=21)
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE,
getUseAvail=TRUE)
predObj$mu.x
predObj$predObs.x
predObj$se.mu.x
predTime = seq(1, 21, len=21)
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.8
sigma_proc = 3
delta = 1 # Time step
steps = 100
all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel
# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error
# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))
# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat))
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)
for(i in 2:(steps + 1)){
alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
all_locs[, i] = alpha_next
}
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
lines(locs[1, ], locs[2, ])
# Format the data for fitting with crawl
sim_dat = data.frame(t(locs))
sim_dat$time = 1:21
# Format the data for fitting with crawl
sim_dat = data.frame(t(locs))
sim_dat$time = 1:(steps + 1)
colnames(sim_dat) = c("x", "y", "time")
sim_dat
library(crawl)
# a is the initial value for the location vector
# P is the initial correlation matrix
initial = list(a=c(20, 0, 20, 0),
P=diag(c(10000^2,5400^2,10000^2,5400^2)))
fit_sim = crwMLE(mov.mod=~1, data=sim_dat, Time.name="time", coord=c('x', 'y'), initial.state = initial, drift=FALSE)
fit_sim
exp(1.222)
exp(-0.294)
source("../crawl/R/crwPredict.R")
predTime = seq(1, 21, len=21)
source("../crawl/R/crwPredict.R")
predObj <- crwPredict.R(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
predTime = seq(1, 21, len=21)
source("../crawl/R/crwPredict.R")
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
library(crawl)
predTime = seq(1, 21, len=21)
library(crawl)
predObj <- crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
predTime = seq(1, 21, len=21)
library(crawl)
predObj <- crawl::crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
predTime = seq(1, 21, len=21)
library(crawl)
predObj <- crawl::crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
getUseAvail=TRUE)
predObj
predTime = seq(1, 21, len=21)
library(crawl)
predObj <- crawl::crwPredict(object.crwFit=fit_sim,
predTime,
speedEst=TRUE,
flat=TRUE)
crwPredictPlot(predObj, "map")
