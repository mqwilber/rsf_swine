---
title: "R Notebook"
output: html_notebook
---

Testing the CTCRW model on a pig trajectory using the crawl package

## Simulating a CTCRW model using the framework described in Johnson et al. 2008, Ecology

The model is formulated as a state space Markov model.

Define the parameters and matrices of the model

```{r}

get_T = function(beta, delta){
  # Get the T matrix of the state space representation
  
  Tmat = matrix(c(1, (1 - exp(-beta*delta)) / beta, 
                 0,   exp(-beta*delta)), nrow=2, ncol=2, 
                byrow=TRUE)
  return(Tmat)
}

get_Q = function(beta, sigma, delta){
  # Get the Q matrix of the state-space formulation
  
    # beta : temporal auto-correlation parameter. Bigger beta, less directional persistence
  # delta : time step
  # sigma : variability in velocity
  
  # Velocity variance
  zeta_var = sigma^2*(1 - exp(-2*beta*delta)) / 2*beta
  
  # Location variance
  xi_var = (sigma^2 / beta^2)*(delta - (2/beta)*(1 - exp(-beta*delta)) +
                                 (1 / (2*beta))*(1 - exp(-2*beta*delta)))
  
  # Covariance between velocity and location
  vl_covar = (sigma^2 / (2*beta^2))*(1 - 2*exp(-beta*delta) +
                                    exp(-2*beta*delta))
  
  Q = matrix(c(xi_var, vl_covar, vl_covar, zeta_var), nrow=2, ncol=2,
             byrow = TRUE)
  return(Q)
  
}

```

Simulate the random walk

```{r}

# First two are location and velocity in one direction, second two are
# location and velocity in another direction. 2D vector
start_locvel = c(20, 0, 20, 0)
beta = 0.8
sigma_proc = 3
delta = 1 # Time step
steps = 100

all_locs = array(NA, dim=c(4, steps + 1))
all_locs[, 1] = start_locvel

# These are for one dimension
Tmat = get_T(beta, delta)
Qmat = get_Q(beta, sigma_proc, delta) # location and velocity vcov
eta_mean = rep(0, 4) # location and velocity process error

# Observation matrix
zeromat = matrix(0, nrow=2, ncol=2)
Zvect = array(c(1, 0), dim=c(2, 1))

# Build the 4 dimensional vectors
Tfull = rbind(cbind(Tmat, zeromat), cbind(zeromat, Tmat)) 
Qfull = rbind(cbind(Qmat, zeromat), cbind(zeromat, Qmat))
Zfull = rbind(Zvect, Zvect)


for(i in 2:(steps + 1)){
  
  alpha_next = Tfull %*% all_locs[, i - 1] + MASS::mvrnorm(1, eta_mean, Qfull)
  all_locs[, i] = alpha_next 

}

```

```{r}
# Plot locations
locs = all_locs[c(1, 3), ]
plot(locs[1, ], locs[2, ])
lines(locs[1, ], locs[2, ])
```

```{r}
# Format the data for fitting with crawl
sim_dat = data.frame(t(locs))
sim_dat$time = 1:(steps + 1)
colnames(sim_dat) = c("x", "y", "time")
sim_dat
```


```{r}
library(crawl)

# a is the initial value for the location vector
# P is the initial correlation matrix
initial = list(a=c(20, 0, 20, 0), 
               P=diag(c(10000^2,5400^2,10000^2,5400^2)))
fit_sim = crwMLE(mov.mod=~1, data=sim_dat, Time.name="time", coord=c('x', 'y'), initial.state = initial, drift=FALSE)

```

```{r}
fit_sim
```

```{r,message=FALSE}
predTime = seq(1, 21, len=21)

library(crawl)
predObj <- crawl::crwPredict(object.crwFit=fit_sim, 
                      predTime, 
                      speedEst=TRUE, 
                      flat=TRUE)
```


Now, view the predicted movement path

```{r,message=FALSE}
crwPredictPlot(predObj, "map")
```

Now, for any given observed point

## Empirical data analysis

**Goal**:  For each data point in the movement trajectory, be able to draw a use and availability distribution.

**0. Load in the data**

```{r}
dat = read.csv("~/Desktop/Data_for_Mark/GPS_data/DataforRSFstudy/RSFData_MI/GPS_Collar36635_033116.CSV")
colnames(dat)
```

1. Convert time stamp to POSIX

```{r}
times = as.character(dat$Date...Time..GMT.)
temp_time = strptime(times,format='%m/%d/%Y %H:%M:%S')
pos_times = as.POSIXct(temp_time, tz="GMT")
dat$Time = pos_times
```

Also, I want to subset to just look at year 2015 and month 10

```{r}
trun_dat = dat[(lubridate::month(dat$Time) == 10) & (lubridate::year(dat$Time) == 2015), ]
```

2. Project lat and long

```{r}
# Just include the necessary columns for the movement model
short_dat = trun_dat[c("Time", "Longitude", "Latitude")]
short_dat = short_dat[complete.cases(short_dat), ]
```


```{r}
library(sp)
library(rgdal)
coordinates(short_dat) <- ~Longitude+Latitude
proj4string(short_dat) <- CRS("+proj=longlat")

# This is projecting lat long to NAD83 in the appropriate rectangle that is centered on Michigan
short_dat <- spTransform(short_dat, CRS("+init=epsg:3078"))
```

Plot the projection to see what the data actuall look like

```{r}
plot(short_dat@coords[, 2], short_dat@coords[, 1])
print(nrow(short_dat))
```

3. Set the initial conditions

```{r}
initial = list(a=c(coordinates(short_dat)[1,1],0,
                   coordinates(short_dat)[1,2],0),
               P=diag(c(10000^2,54000^2,10000^2,5400^2)))

# Prior
ln.prior = function(theta){-abs(theta[4]-3)/0.5}
```

```{r}
displayPar(mov.model=~1,
           data=short_dat)
```

```{r}
set.seed(123)
fit1 <- crwMLE(mov.model=~1,
               data=short_dat, 
               Time.name="Time",
               initial.state=initial,
               prior=ln.prior,
               control=list(maxit=30, trace=0,REPORT=1),
               initialSANN=list(maxit=200, trace=0, REPORT=1))
```

```{r}
fit1
```