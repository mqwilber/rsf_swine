---
title: "CTMC model for pigs"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
# Load in necessary packages
library(data.table)
library(raster)
library(ggplot2)
library(lubridate)
library(crawl)
library(sp)
library(rgdal)
library(rgeos)
library(ctmcmove)
library(splines)

## Useful functions
source('/Users/mqwilber/Repos/rsf_swine/code/pigfxns.R')

```

For a single pig in the Camp Bullis data set, implement the movement method proposed by Hanks et al. 2015 to understand the resource utilization function.

## Step 1: Format the data and extract a single pig

```{r}

dt = fread("/Users/mqwilber/Repos/rsf_swine/data/formatted/full_pig_data_cleaned.csv")

# Extract texas pigs
txpigs = dt[study == "txcamp"]
rm(dt)

# Convert datetime
txpigs$datetimef = as.POSIXct(strptime(txpigs$datetime, format='%Y-%m-%d %H:%M:%S'), tz="GMT")

# Extract pigs with the most observations
cntpigs = txpigs[, list(counts=length(datetime)), by=list(pigID)][order(counts, decreasing = T)]
head(cntpigs)


# Look for overlap
runsdt = txpigs[, list(runs=runs(datetimef, clength=500, ctime=30, ctimemin=0)), by="pigID"]
runsIDs = runsdt$pigID[runsdt$runs]

# extract the specific IDs
ind = array(FALSE, dim=nrow(txpigs))
for(ID in runsIDs){
	ind = ind | txpigs$pigID == ID
}

pigdt = txpigs[ind]
dim(pigdt)
unique(pigdt$pigID)

# Look for where the pigs are overlapping in time
minmax = pigdt[, list(min=min(datetimef), max=max(datetimef)), by="pigID"]
minmax

# Let's just focus on 03-03 for the following analysis
redpigs = minmax[month(min) == 3 & day(min) == 3]$pigID
redpigs

ind = array(FALSE, dim=nrow(pigdt))
for(ID in redpigs){
	ind = ind | pigdt$pigID == ID
}

# Get the test pigs
testpigsdt = pigdt[ind]
dim(testpigsdt)
unique(testpigsdt$pigID)
sum(table(testpigsdt$pigID))
```

```{r}
ind = (testpigsdt$pigID == testpigsdt$pigID[1])
pig1 = testpigsdt[ind][1:3000, ]

```

## Step 2. Load in raster data

1. CropScape data for the area of interest

```{r}
plot(pig1$longitude, pig1$latitude)

# Get the bounding box for the pig data so we can apply it to the raster file
ymin = min(pig1$latitude)
ymax = max(pig1$latitude)
xmin = min(pig1$longitude)
xmax = max(pig1$longitude)
```

Load in a clip the cropscape raster file

```{r}
rcval = raster("~/Downloads/CDL_2016_clip_20180118163303_1712778437/CDL_2016_clip_20180118163303_1712778437.tif")
# Crop the raster with some arbitrary buffer
buffer = 0.001
rcval1 = crop(rcval, extent(xmin - buffer, xmax + buffer, ymin - buffer, ymax + buffer))
rcval1
plot(rcval1)
points(pig1$longitude, pig1$latitude, cex=0.1)
```

```{r}
a = area(rcval1)
sqrt(values(a)[1] * 1000^2)
```

Close to 30 meter resolution on the grid cells.

Plenty of other rasters to consider, but let's start here.  Also, will need to convert these raster values to something more quantitative. Either zero or ones

```{r}
table(values(rcval1))
developed = forest = crop = water = dummy = rcval1
values(developed) = (values(developed) == 121) | 
                    (values(developed) == 122) | 
                    (values(developed) == 123) | 
                    (values(developed) == 124) | 
                    (values(developed) == 131)
        

values(forest)[values(rcval1) == 142] = 0 # Forest habitat
values(forest)[values(rcval1) != 142] = 1 # Not forest

values(water) = values(water) == 111
values(crop) = values(crop) < 100
values(dummy) = 0

```

```{r}
nms = c("developed", "forest", "crop", "water")
loc.stack = stack(forest, dummy) #stack(developed, forest, crop, water)
names(loc.stack) = c("forest_loc", "dummy_loc") #paste0(nms, "_loc")
grad.stack = stack(forest, dummy) #stack(developed, forest, crop, water)
names(grad.stack) = c("forest_grad", "dummy_grad") #paste0(nms, "_grad")
```

## Step 3: Fit a spline-based continuous time movement model.

```{r}

# Scale lat and long for fitting
pig1$latsc = scale(pig1$latitude)
pig1$longsc = scale(pig1$longitude)

# Fitting an arbitrarily spline model just for now
fitlong = lm(longsc ~ bs(datetimef, df=100), data=pig1)
fitlat = lm(latsc ~ bs(datetimef, df=100), data=pig1)

iterpLong = approxfun(pig1$datetimef, pig1$longsc)
iterpLat = approxfun(pig1$datetimef, pig1$latsc)

plot(predict(fitlong), predict(fitlat), type="l")
points(pig1$longsc, pig1$latsc, col='red', cex=0.1)

plot(pig1$datetimef, pig1$longsc, type="l")
lines(pig1$datetimef, predict(fitlong), col="red")

plot(pig1$datetimef, pig1$latsc, type="l")
lines(pig1$datetimef, predict(fitlat), col="red")

```

Use the continous spline representations to build a continuous trajectory spaced at hour intervals over the entire course of the study

```{r}
mintime = min(pig1$datetimef)
maxtime = max(pig1$datetimef)
predTime = seq(mintime, maxtime, by="15 mins")
predlong =iterpLong(predTime)
predlat = iterpLat(predTime)

# predlong =  predict(fitlong, newdata=data.frame(datetimef=predTime))
# predlat = predict(fitlat, newdata=data.frame(datetimef=predTime))


# Convert back to the natural scale
predlongT = predlong*sd(pig1$longitude) + mean(pig1$longitude)
predlatT = predlat*sd(pig1$latitude) + mean(pig1$latitude)

# Make sure the projected paths don't go off the landscape
plot(rcval1)
points(predlongT, predlatT, cex=0.1,)

```

## Step 4: Set up the data for CTMC analysis

Following the steps in the Wilson et al., Calculating where each point is.
Pretty slow over all

```{r}

# Specify where the animal can move on the lanscape
move_field = rcval1
values(move_field) = 1

# Transition matrix
trans = transition(move_field, prod, 4)

# Convert the path to resident times...pretty slow
path = list(xy=cbind(predlongT, predlatT), t=as.vector(predTime))
ctmc = path2ctmc(xy=path$xy, t=path$t, rast=grad.stack)

```

Convert data so that we can use a glm to estimate resource parameters.

```{r}
# Brilliant! Hanks encodes the CRW term for you which accounts for the autocorrelation in the random walk.
glm_data = ctmc2glm(ctmc, loc.stack, grad.stack)
```

```{r}
# Don't include the gradient information as it is not useful as zeros and 1s
fit = glm(z ~ forest_loc + crw,
              family="poisson", offset=log(tau), data=glm_data)

```

```{r}
summary(fit)
```

```{r}
summary(fit)
```

Evidence that pig moves slower through the forest habitat.  Consistent with
what other models predict.

## Step 4: Get the rate matrix 

```{r}
getR = function (object, stack.static, stack.grad, normalize.gradients = FALSE, 
    grad.point.decreasing = TRUE, directions = 4, zero.idx = integer(), 
    coef){
    # same as ctmcmove::get.rate.matrix, but allows you to use dummy variables. ctmcmove has a bug along these lines.
    if (inherits(stack.static, "Raster")) {
        p.static = nlayers(stack.static)
    }
    else p.static = 0
    p.crw = 0
    if (inherits(stack.grad, "Raster")) {
        p.grad = nlayers(stack.grad)
        stack.gradient = rast.grad(stack.grad)
        if (normalize.gradients) {
            lengths = sqrt(stack.gradient$grad.x^2 + stack.gradient$grad.y^2)
            stack.gradient$grad.x <- stack.gradient$grad.x/lengths
            stack.gradient$grad.y <- stack.gradient$grad.y/lengths
        }
    }
    else {
        p.grad = 0
    }
    p = p.static + p.crw + p.grad
    if (class(stack.static) == "RasterStack") {
        examplerast = stack.static[[1]]
    }
    if (class(stack.static) == "RasterLayer") {
        examplerast = stack.static
    }
    locs = 1:ncell(examplerast)
    nn = ncell(examplerast)
    R = Matrix(0, nrow = nn, ncol = nn, sparse = TRUE)
    adj = adjacent(examplerast, locs, pairs = TRUE, sorted = TRUE, 
        id = TRUE, directions = directions)
    idx.mot = adj[, 2:3]
    if (p.static > 0) {
        X = data.frame(values(stack.static)[idx.mot[, 1], ])
        for(nm in names(X)){
          X[[nm]] = as.numeric(X[[nm]])
        }
        
    }
    start.cells = idx.mot[, 1]
    adj.cells = idx.mot[, 2]
    xy.cell = xyFromCell(examplerast, start.cells)
    xy.adj = xyFromCell(examplerast, adj.cells)
    v.adj = (xy.adj - xy.cell)/sqrt(apply((xy.cell - xy.adj)^2, 
        1, sum))
    if (p.grad > 0) {
        X.grad = v.adj[, 1] * stack.gradient$grad.x[start.cells, 
            ] + v.adj[, 2] * stack.gradient$grad.y[start.cells, 
            ]
        if (grad.point.decreasing == TRUE) {
            X.grad = -X.grad
        }
        X = cbind(X, X.grad)
    }
    X$tau = 1
    X$crw = 0
    if (missing(coef)) {
        R[idx.mot] = as.vector(predict(object, newdata = X, type = "response"))
    }
    else {
        if (length(coef) != length(coefficients(object))) 
            stop("'coef' vector is not the correct length!")
        R[idx.mot] = exp(X %*% coef)
    }
    if (length(zero.idx) > 0) {
        R[zero.idx, zero.idx] = 0
    }
    R
}
```

```{r}

loc.stack = stack(developed, forest, crop)
grad.stack = stack(developed, forest, crop)
names(loc.stack) = paste0(nms[-4], "_loc")
names(grad.stack) = paste0(nms[-4], "_grad")

# Note that this CTMC is not positive recurrent as all forest cells have the same probability and the animal can wonder freely between those
# cells.  Pretty sure at least.  This would make sense why the the pi distribution looks so funky!
R = tget(fit, loc.stack, grad.stack)

```

```{r}
## Simulate movement of individual on the landscape

get_direction = function(current, indices){
  # Given a vector of cell indices, determine if a cell is above (1), below (-1), left (-2) or right (2)
  #
  # Parameters
  # ----------
  # current : index of the current cell
  # indices : indices of the four rook-based cells
  #
  # Returns
  # -------
  # Directions of each indices relative to current
  
  diffs = current - indices
  direction = array(NA, dim=length(diffs))
  
  direction[diffs > 1] = 1 # north
  direction[diffs == -1] = 2 # east
  direction[diffs < -1] = -1 # south
  direction[diffs == 1] = -2 # west
  
  return(direction)
}

set_direction_weights = function(past_direction, next_directions){
  # Weight the direction of movement based on a correlated random walk.
  #
  # Following Hank et al. 2015, this is taking the dot product between a unit vectors pointing
  # either up, down, left or right.  Same direction = 1, Opposite direction = -1, Else = 0.
  #
  # Parameters
  # ----------
  # past_direciton : either 1, 2, -1, -2 (see get_direction)
  # next_directions : from get_direction
  
  # Returns
  # -------
  # next_direction : the weights on the next directions (1, -1, 0, 0)
  
  weights = array(0, dim=length(next_directions))
  weights[past_direction == next_directions] = 1
  weights[past_direction == -1*next_directions] = -1
  return(weights)

}



sim_traj = function(R, fit, start, steps=100){
  # Simulate the discrete time steps of animal movement based on the CTMC generator matrix R, 
  # and the the GLM model.
  #
  # Parameters
  # ----------
  # R : CMTC generators matrix without rates on the diagonals (from get.rate.matrix())
  # fit : Fittted GLM object, with crw as a coefficient.
  # start : index of starting cell.  Should be between 1:nrow(R)
  # steps: Number of steps in the simulation
  #
  # Returns
  # -------
  # list of position indices, interevent times, and step_directions
  
  
  # Build the transition matrix
  zero.idx = which(colSums(R) == 0)
  n.0 = length(zero.idx)
  if (length(zero.idx) > 0) {
    R = R[-zero.idx, -zero.idx]
  }
  n = nrow(R)
  one = matrix(1, n, 1)
  # P = R
  # 
  # # Discrete time transition matrix
  # P = Diagonal(x = 1/as.numeric(P %*% one)) %*% P
  
  # 
  positions = array(NA, dim=steps + 1)
  step_direction = array(NA, dim=steps + 1)
  time = array(NA, dim=steps + 1)
  time[1] = 0
  
  step_direction[i] = 1 # Start moving north

  step_direction[i] = 0
  positions[1] = start
  for(i in 2:(steps + 1)){
    
    
    indices = which(R[positions[i - 1], ] != 0)
    
    # Compute CRW weights
    directions = get_direction(positions[i - 1], indices) # Directions of indices
    weights = set_direction_weights(step_direction[i- 1], directions)
    crw = exp(fit$coefficients['crw']*weights)
    
    rates = R[positions[i - 1], indices]*crw
    time[i] = rexp(1, sum(rates)) # Interevent time
    probs = rates / sum(rates)
    samp = rmultinom(1, 1, probs)
    
    positions[i] = indices[as.logical(samp)]
    step_direction[i] = directions[as.logical(samp)]
    
  }
  
  return(list(positions=positions, steps=step_direction, time=time))
  
}
```

```{r}
start = 150 + 87*3#sample(1:nrow(R), 1)
traj = sim_traj(R, fit, start, steps=5000)
```

```{r}
trajRast = forest
values(trajRast) = 0
values(trajRast)[traj$positions] = 200
path = rasterToPoints(trajRast, function(x) x == 200)
plot(-1*forest + 1)

points(path[, "x"], path[, "y"], pch=18, cex=0.4)

```

```{r}
# Cumulative time elapsed
plot(cumsum(traj$time) / (60 * 60 * 24), 1:length(traj$time), type="l", xlab="Days", ylab="Events")
```

What does movement distance look like?

```{r}
library(geosphere)

get_distance_vect = function(longlat){
  # Calculate tghe distance that a pig traveled
  
  longs = longlat$longitude
  lats = longlat$latitude
  
  # Match distance vectors
  v1 = cbind(longs[-length(longs)], lats[-length(lats)])
  v2 = cbind(longs[-1], lats[-1])
  
  tuples = lapply(1:nrow(v1), function(i) list(v1[i, ], v2[i, ]))
  distvect = lapply(tuples, function(x) distm(x=x[[1]], y=x[[2]], fun=distHaversine))
  # 
  return(distvect)
}

# Unique cells visited
cells = extract(trajRast, path[, c('x', 'y')], cellnumbers=T)
locs = as.data.table(path[, c('x','y')])
locs$cells = cells[, 'cells']

obs = data.table(cells=traj$positions, time=c(cumsum(traj$time)))
obs = merge(obs, locs, key="cells")[order(time)]

```


```{r}
plot(obs$time, obs$x, type="l")
plot(obs$time, obs$y, type="l")
plot(obs$x, obs$y, type="l")
```



Alright!  This seems to be working decently well. 

```{r}
longlat = obs[, c('x', 'y')]
names(longlat) = c('longitude', 'latitude')
dist = get_distance_vect(longlat)

plot(obs$time[-1] / (60 * 60 * 24), cumsum(dist), type="l", ylab="Cum. distance", xlab="Days")
```
