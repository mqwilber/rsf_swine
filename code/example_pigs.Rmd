---
title: "CTMC model for pigs"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
# Load in necessary packages
library(data.table)
library(raster)
library(ggplot2)
library(lubridate)
library(crawl)
library(sp)
library(rgdal)
library(rgeos)
library(ctmcmove)
library(splines)

## Helper functions
source('/Users/mqwilber/Repos/rsf_swine/code/pigfxns.R')

```

For a single pig in the Camp Bullis data set, implement the movement method proposed by Hanks et al. 2015 to understand the resource utilization function.

## Step 1: Format the data and extract a single pig

```{r}

dt = fread("/Users/mqwilber/Repos/rsf_swine/data/formatted/full_pig_data_cleaned.csv")

# Extract texas pigs
txpigs = dt[study == "txcamp"]
rm(dt)

# Convert datetime
txpigs$datetimef = as.POSIXct(strptime(txpigs$datetime, format='%Y-%m-%d %H:%M:%S'), tz="GMT")

# Extract pigs with the most observations
cntpigs = txpigs[, list(counts=length(datetime)), by=list(pigID)][order(counts, decreasing = T)]
head(cntpigs)


# Look for overlap
runsdt = txpigs[, list(runs=runs(datetimef, clength=500, ctime=30, ctimemin=0)), by="pigID"]
runsIDs = runsdt$pigID[runsdt$runs]

# extract the specific IDs
ind = array(FALSE, dim=nrow(txpigs))
for(ID in runsIDs){
	ind = ind | txpigs$pigID == ID
}

pigdt = txpigs[ind]
dim(pigdt)
unique(pigdt$pigID)

# Look for where the pigs are overlapping in time
minmax = pigdt[, list(min=min(datetimef), max=max(datetimef)), by="pigID"]
minmax

# Let's just focus on 03-03 for the following analysis
redpigs = minmax[month(min) == 3 & day(min) == 3]$pigID
redpigs

ind = array(FALSE, dim=nrow(pigdt))
for(ID in redpigs){
	ind = ind | pigdt$pigID == ID
}

# Get the test pigs
testpigsdt = pigdt[ind]
dim(testpigsdt)
unique(testpigsdt$pigID)
sum(table(testpigsdt$pigID))
```

```{r}
ind = (testpigsdt$pigID == testpigsdt$pigID[1])
pig1 = testpigsdt[ind][1:3000, ]

```

## Step 2. Load in raster data

1. CropScape data for the area of interest

```{r}
plot(pig1$longitude, pig1$latitude)

# Get the bounding box for the pig data so we can apply it to the raster file
ymin = min(pig1$latitude)
ymax = max(pig1$latitude)
xmin = min(pig1$longitude)
xmax = max(pig1$longitude)
```

Load in a clip the cropscape raster file

```{r}
rcval = raster("~/Downloads/CDL_2016_clip_20180118163303_1712778437/CDL_2016_clip_20180118163303_1712778437.tif")
# Crop the raster with some arbitrary buffer
buffer = 0.001
rcval1 = crop(rcval, extent(xmin - buffer, xmax + buffer, ymin - buffer, ymax + buffer))
rcval1
plot(rcval1)
points(pig1$longitude, pig1$latitude, cex=0.1)
```

```{r}
a = area(rcval1)
sqrt(values(a)[1] * 1000^2)
```

Close to 30 meter resolution on the grid cells.

Plenty of other rasters to consider, but let's start here.  Also, will need to convert these raster values to something more quantitative. Either zero or ones

```{r}
table(values(rcval1))
developed = forest = crop = water = dummy = rcval1
values(developed) = (values(developed) == 121) | 
                    (values(developed) == 122) | 
                    (values(developed) == 123) | 
                    (values(developed) == 124) | 
                    (values(developed) == 131)
        

values(forest)[values(rcval1) == 142] = 0 # Forest habitat
values(forest)[values(rcval1) != 142] = 1 # Not forest

values(water) = values(water) == 111
values(crop) = values(crop) < 100
values(dummy) = 0

```

```{r}
nms = c("developed", "forest", "crop", "water")
loc.stack = stack(forest, dummy) #stack(developed, forest, crop, water)
names(loc.stack) = c("forest_loc", "dummy_loc") #paste0(nms, "_loc")
grad.stack = stack(forest, dummy) #stack(developed, forest, crop, water)
names(grad.stack) = c("forest_grad", "dummy_grad") #paste0(nms, "_grad")
```

## Step 3: Fit a spline-based continuous time movement model.

```{r}

# Scale lat and long for fitting
pig1$latsc = scale(pig1$latitude)
pig1$longsc = scale(pig1$longitude)

# Fitting an arbitrarily spline model just for now
fitlong = lm(longsc ~ bs(datetimef, df=100), data=pig1)
fitlat = lm(latsc ~ bs(datetimef, df=100), data=pig1)

iterpLong = approxfun(pig1$datetimef, pig1$longsc)
iterpLat = approxfun(pig1$datetimef, pig1$latsc)

plot(predict(fitlong), predict(fitlat), type="l")
points(pig1$longsc, pig1$latsc, col='red', cex=0.1)

plot(pig1$datetimef, pig1$longsc, type="l")
lines(pig1$datetimef, predict(fitlong), col="red")

plot(pig1$datetimef, pig1$latsc, type="l")
lines(pig1$datetimef, predict(fitlat), col="red")

```

Use the continous spline representations to build a continuous trajectory spaced at hour intervals over the entire course of the study

```{r}
mintime = min(pig1$datetimef)
maxtime = max(pig1$datetimef)
predTime = seq(mintime, maxtime, by="15 mins")
predlong =iterpLong(predTime)
predlat = iterpLat(predTime)

# predlong =  predict(fitlong, newdata=data.frame(datetimef=predTime))
# predlat = predict(fitlat, newdata=data.frame(datetimef=predTime))


# Convert back to the natural scale
predlongT = predlong*sd(pig1$longitude) + mean(pig1$longitude)
predlatT = predlat*sd(pig1$latitude) + mean(pig1$latitude)

# Make sure the projected paths don't go off the landscape
plot(rcval1)
points(predlongT, predlatT, cex=0.1)

```

## Step 4: Set up the data for CTMC analysis

Following the steps in the Wilson et al., Calculating where each point is.
Pretty slow over all

```{r}

# Specify where the animal can move on the lanscape
move_field = rcval1
values(move_field) = 1

# Transition matrix
trans = transition(move_field, prod, 4)

# Convert the path to resident times...pretty slow
path = list(xy=cbind(predlongT, predlatT), t=as.vector(predTime))
ctmc = path2ctmc(xy=path$xy, t=path$t, rast=grad.stack)

```

Convert data so that we can use a glm to estimate resource parameters.

```{r}
# Brilliant! Hanks encodes the CRW term for you which accounts for the autocorrelation in the random walk.
glm_data = ctmc2glm(ctmc, loc.stack, grad.stack)
```

```{r}
# Don't include the gradient information as it is not useful as zeros and 1s
fit = glm(z ~ forest_loc + crw,
              family="poisson", offset=log(tau), data=glm_data)

```

```{r}
summary(fit)
```

```{r}
summary(fit)
```

Evidence that pig moves slower through the forest habitat.  Consistent with
what other models predict.

## Step 4: Get the rate matrix 

```{r}

loc.stack = stack(developed, forest, crop)
grad.stack = stack(developed, forest, crop)
names(loc.stack) = paste0(nms[-4], "_loc")
names(grad.stack) = paste0(nms[-4], "_grad")

# Note that this CTMC is not positive recurrent as all forest cells have the same probability and the animal can wonder freely between those
# cells.  Pretty sure at least.  This would make sense why the the pi distribution looks so funky!
R = tget(fit, loc.stack, grad.stack)

```


```{r}
## Simulate movement of individual on the landscape
start = 150 + 87*3#sample(1:nrow(R), 1)
traj = sim_traj(R, fit, start, steps=5000)
```

```{r}
trajRast = forest
values(trajRast) = 0
values(trajRast)[traj$positions] = 200
path = rasterToPoints(trajRast, function(x) x == 200)
plot(-1*forest + 1)

points(path[, "x"], path[, "y"], pch=18, cex=0.4)

```

```{r}
# Cumulative time elapsed
plot(cumsum(traj$time) / (60 * 60 * 24), 1:length(traj$time), type="l", xlab="Days", ylab="Events")
```

What does movement distance look like?

```{r}

# Unique cells visited
cells = extract(trajRast, path[, c('x', 'y')], cellnumbers=T)
locs = as.data.table(path[, c('x','y')])
locs$cells = cells[, 'cells']

obs = data.table(cells=traj$positions, time=c(cumsum(traj$time)))
obs = merge(obs, locs, key="cells")[order(time)]

```


```{r}
plot(obs$time, obs$x, type="l")
plot(obs$time, obs$y, type="l")
plot(obs$x, obs$y, type="l")
```



```{r}
longlat = obs[, c('x', 'y')]
names(longlat) = c('longitude', 'latitude')
dist = get_distance_vect(longlat)

plot(obs$time[-1] / (60 * 60 * 24), cumsum(dist), type="l", ylab="Cum. distance", xlab="Days")
```
