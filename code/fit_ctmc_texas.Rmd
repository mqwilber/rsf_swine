---
title: "Fitting CTMC model to Texas pigs"
output: html_document
---

```{r}
library(data.table)
library(raster)
library(ggplot2)
library(lubridate)
library(crawl)
library(sp)
library(rgdal)
library(rgeos)
library(ctmcmove)
library(splines)
library(fda)
source('/Users/mqwilber/Repos/rsf_swine/code/pigfxns.R')
```

# Step 0: Load in and format the pig data from txcamp.

For each pig, remove unrealistic observations

```{r}
dat = fread("../data/formatted/full_pig_data.csv")
tcdat = dat[study == "txcamp"]
rm(dat) # Free up some space

# At least three pigs have some errant movements
tplot = ggplot(tcdat) + geom_path(aes(x=longitude, y=latitude)) + facet_wrap(~pigID)
# tplot
```

There are a few pigs where we seem to have errant movements: txcamp20141, txcamp20150, txcamp20169.  For these pigs, let's identify potential outliers in movement.


```{r}
badpigs =c("txcamp20141", "txcamp20150", "txcamp20169")

badout = array(NA, dim=3)
fullind = array(NA, dim=3)

for(i in 1:length(badpigs)){
  
  bp = badpigs[i]
  bpdat = tcdat[pigID == bp, list(longitude, latitude)]
  kmeans.result = kmeans(bpdat, 1)
  centers = kmeans.result$centers[kmeans.result$cluster, ]
  distances <- sqrt(rowSums((bpdat - centers)^2))
  
  outliers <- order(distances, decreasing=T)[1:5]

  print(outliers) 
  badout[i] = outliers[1]
  fullind[i] = which((tcdat$pigID == bp) & (tcdat$longitude == bpdat$longitude[outliers[1]]) & (tcdat$latitude == bpdat$latitude[outliers[1]]))
  
  plot(bpdat[,list(longitude, latitude)], pch=19, col=kmeans.result$cluster, cex=1)
  points(kmeans.result$centers[, c("longitude", "latitude")], col=1:3, pch=15, cex=2)
  points(bpdat[outliers, c("longitude", "latitude")], pch="+", col=4, cex=3)

  
}

```

Remove the substantial outliers.

```{r}
trimdat = tcdat[-fullind, ]
ggplot(trimdat) + geom_path(aes(x=longitude, y=latitude)) + facet_wrap(~pigID)
```


Now, given that behavior can change over the course of the season, we likely want to make inference over consistent time intervals. Let's look at a plot of collaring times.

```{r}
trimdat$datetime = as.POSIXct(trimdat$datetime, tz="GMT")
collarDur = trimdat[, list(mindate=min(datetime), maxdate=max(datetime)), by=pigID]
ggplot(data=collarDur) + geom_linerange(aes(x=pigID, ymin=mindate, ymax=maxdate)) + 
          theme(axis.text.x = element_text(angle = 90, hjust = 1,  size=3)) + 
          scale_y_datetime(breaks = seq(min(collarDur$mindate), max(collarDur$maxdate), by="month"))
```

Which pigs are between have at least `clength` consecutive fixes of `ctime` minutes or less?
```{r}
lrdat = trimdat[, list(lr=runs(datetime, ctime=200, clength=5000)), by=pigID]
longdat = merge(trimdat, lrdat, by="pigID")[lr == TRUE]

collarDur2 = longdat[, list(mindate=min(datetime), maxdate=max(datetime)), by=pigID]
ggplot(data=collarDur2) + geom_linerange(aes(x=pigID, ymin=mindate, ymax=maxdate)) + 
          theme(axis.text.x = element_text(angle = 90, hjust = 1,  size=10)) + 
          scale_y_datetime(breaks = seq(min(collarDur$mindate), max(collarDur$maxdate), by="month"))
```

```{r}
n = nrow(longdat)
deltas = longdat[order(pigID, datetime), list(deltat=diff(datetime)),  by=pigID]
deltas[, list(units=units(deltat)), by=pigID]
max(deltas$deltat)
min(deltas$deltat)
tplot = ggplot(deltas) + geom_boxplot(aes(x="pig", y=deltat)) + facet_wrap(~pigID)

for(pid in unique(longdat$pigID)){

  tp = longdat[pigID == pid, ]
  #plot(tp$datetime, main=pid, type="l")
  
  if(pid == "txcamp20154"){
    imax = which.max(deltas[pigID == pid, deltat])
    print(tp[c(imax, imax + 1), datetime])
    exdate = tp[c(imax + 1), datetime]
    
  }
  
}
  
```

Exclude everything before "2016-06-20 00:00:09 GMT" for "txcamp20154" as there is a large time gap.  This looks to be the same individual pig though based on the data.

```{r}
longdat2 = longdat[!(pigID == "txcamp20154" & datetime < exdate), ]

collarDur3 = longdat2[, list(mindate=min(datetime), maxdate=max(datetime)), by=pigID]
ggplot(data=collarDur3) + geom_linerange(aes(x=pigID, ymin=mindate, ymax=maxdate)) + 
          theme(axis.text.x = element_text(angle = 90, hjust = 1,  size=10)) + 
          scale_y_datetime(breaks = seq(min(collarDur3$mindate), max(collarDur3$maxdate), by="month"))
```

A total of 26 pigs to consider

```{r}
for(pid in unique(longdat2$pigID)){
  tp = longdat2[pigID == pid, ]
  plot(tp$datetime, type="l")
}

longdat2[, list(maxdelta=max(diff(datetime)), mindelta=min(diff(datetime)), meddelta=median(diff(datetime))), by=pigID]
```

The largest time gap we have is around 24 hours. It might be useful to clean that data further, but for now we will use imputation to account for the uncertainty around these trajectories.  Will be important to assess the sensitivity of the analysis to some of these gaps.

## Step 1: Load in and format the necessary covariate data

**Covariates to use**

1. Forest cover (binary)
2. Elevation (gradient)
3. Temperature (time-varying covariate)
4. NDVI/EVI forest cover

```{r}
source("pigfxns.R")
pig1 = longdat2[pigID == "txcamp20160"]
extobj = extent(min(pig1$longitude), max(pig1$longitude), min(pig1$latitude), max(pig1$latitude))

loc_stack = process_covariates(c("temperature", "croplayer"), "txcamp", extobj, min(pig1$datetime), max(pig1$datetime), ext="loc")
grad_stack = process_covariates(c("elevation"), "txcamp", extobj, min(pig1$datetime), max(pig1$datetime), ext="grad")

# Ensure projections are the same
locnames = names(loc_stack)
loc_stackproj = stack(lapply(loc_stack, function(x) projectRaster(x, loc_stack[['croplayer_loc']], method="ngb")))
grad_stackproj = stack(lapply(grad_stack, function(x) projectRaster(x, loc_stack[['croplayer_loc']], method="bilinear")))
```

## Step 2: Fit a continuous time basis functions and get the continuous path

Two options here:

1. Use the `mcmc.fmove` in ctmcmove
2. Use the `lm` and `bs` in base R

```{r}

max=nrow(pig1)
xy = as.matrix(pig1[1:max, list(scale(longitude), scale(latitude))])
t = as.numeric(pig1[1:max, datetime])
t = t - mean(t)

bsp = bs(t, df=1000)
knots = attributes(bsp)$knots
b = create.bspline.basis(c(min(t), max(t)), breaks=knots, norder=4)
tpred = seq(min(t), max(t), by=15)
fit = mcmc.fmove(xy, t, b, tpred, QQ="CAR", n.mcmc=400, num.paths.save=30)

plot(xy, type="b")
points(fit$pathlist[[1]]$xy,col="red",type="l")
points(fit$pathlist[[2]]$xy,col="blue",type="l")
points(fit$pathlist[[3]]$xy,col="orange",type="l")

```

So the `mcmc.fmove` function is pretty nice. Can we get a similar (and faster) answer using bs likelihood assumptions

```{r}
Xmat = eval.basis(t, b)

fitlong = lm.fit(Xmat, xy[, 1])
fitlat = lm.fit(Xmat, xy[, 2])
sigma2 = mean(c(sum(fitlong$residuals^2) / fitlong$df.residual, sum(fitlat$residuals^2) / fitlat$df.residual))

Betas1 = coef(fitlong)
Betas2 = coef(fitlat)

Vmat1 = sigma2*solve(t(Xmat)%*%Xmat)
L = chol(Vmat1)

# Ahh, so this is what takes so long with the 
Xpred = eval.basis(tpred, b) # Still pretty slow with the fda package

plot(xy, type="b")
for(i in 1:1){
  long = Xpred %*% (Betas1 + (L %*% rnorm(length(Betas1))))
  lat = Xpred %*% (Betas2 + (L %*% rnorm(length(Betas2))))
  points(long, lat, col=colors()[i + 100], type="l")
}

```

In general, the `lm` approach isn't saving too much time to fitting these bsplines and it is not regularizing, Therefore, mcmc.fmove might be a good way to go. 

## Step 3: Fit the CTMC model using the ctmcmove package

## Step 4: Look at how resources effect movement


