---
title: "Fitting CTMC model to Texas pigs"
output: html_document
---

```{r}
library(data.table)
library(raster)
library(ggplot2)
library(lubridate)
library(sp)
library(rgdal)
library(rgeos)
library(ctmcmove)
library(splines)
library(fda)
source('/Users/mqwilber/Repos/rsf_swine/code/pigfxns.R')
```

# Step 0: Load in and format the pig data from txcamp.

For each pig, remove unrealistic observations

```{r}
dat = fread("../data/formatted/full_pig_data.csv")
tcdat = dat[study == "txcamp"]
rm(dat) # Free up some space

# At least three pigs have some errant movements
tplot = ggplot(tcdat) + geom_path(aes(x=longitude, y=latitude)) + facet_wrap(~pigID)
# tplot
```

There are a few pigs where we seem to have errant movements: txcamp20141, txcamp20150, txcamp20169.  For these pigs, let's identify potential outliers in movement.


```{r}
badpigs =c("txcamp20141", "txcamp20150", "txcamp20169")

badout = array(NA, dim=3)
fullind = array(NA, dim=3)

for(i in 1:length(badpigs)){
  
  bp = badpigs[i]
  bpdat = tcdat[pigID == bp, list(longitude, latitude)]
  kmeans.result = kmeans(bpdat, 1)
  centers = kmeans.result$centers[kmeans.result$cluster, ]
  distances <- sqrt(rowSums((bpdat - centers)^2))
  
  outliers <- order(distances, decreasing=T)[1:5]

  print(outliers) 
  badout[i] = outliers[1]
  fullind[i] = which((tcdat$pigID == bp) & (tcdat$longitude == bpdat$longitude[outliers[1]]) & (tcdat$latitude == bpdat$latitude[outliers[1]]))
  
  plot(bpdat[,list(longitude, latitude)], pch=19, col=kmeans.result$cluster, cex=1)
  points(kmeans.result$centers[, c("longitude", "latitude")], col=1:3, pch=15, cex=2)
  points(bpdat[outliers, c("longitude", "latitude")], pch="+", col=4, cex=3)

  
}

```

Remove the substantial outliers.

```{r}
trimdat = tcdat[-fullind, ]
tp = ggplot(trimdat) + geom_path(aes(x=longitude, y=latitude)) + facet_wrap(~pigID)
```


Now, given that behavior can change over the course of the season, we likely want to make inference over consistent time intervals. Let's look at a plot of collaring times.

```{r}
trimdat$datetime = as.POSIXct(trimdat$datetime, tz="GMT")
collarDur = trimdat[, list(mindate=min(datetime), maxdate=max(datetime)), by=pigID]
ggplot(data=collarDur) + geom_linerange(aes(x=pigID, ymin=mindate, ymax=maxdate)) + 
          theme(axis.text.x = element_text(angle = 90, hjust = 1,  size=3)) + 
          scale_y_datetime(breaks = seq(min(collarDur$mindate), max(collarDur$maxdate), by="month"))
```

Which pigs are between have at least `clength` consecutive fixes of `ctime` minutes or less?
```{r}
lrdat = trimdat[, list(lr=runs(datetime, ctime=200, clength=5000)), by=pigID]
longdat = merge(trimdat, lrdat, by="pigID")[lr == TRUE]

collarDur2 = longdat[, list(mindate=min(datetime), maxdate=max(datetime)), by=pigID]
ggplot(data=collarDur2) + geom_linerange(aes(x=pigID, ymin=mindate, ymax=maxdate)) + 
          theme(axis.text.x = element_text(angle = 90, hjust = 1,  size=10)) + 
          scale_y_datetime(breaks = seq(min(collarDur2$mindate), max(collarDur2$maxdate), by="month"))
```

```{r}
n = nrow(longdat)
deltas = longdat[order(pigID, datetime), list(deltat=diff(datetime)),  by=pigID]
deltas[, list(units=units(deltat)), by=pigID]
max(deltas$deltat)
min(deltas$deltat)
tplot = ggplot(deltas) + geom_boxplot(aes(x="pig", y=deltat)) + facet_wrap(~pigID)

for(pid in unique(longdat$pigID)){

  tp = longdat[pigID == pid, ]
  #plot(tp$datetime, main=pid, type="l")
  
  if(pid == "txcamp20154"){
    imax = which.max(deltas[pigID == pid, deltat])
    print(tp[c(imax, imax + 1), datetime])
    exdate = tp[c(imax + 1), datetime]
    
  }
  
}
  
```

Exclude everything before "2016-06-20 00:00:09 GMT" for "txcamp20154" as there is a large time gap.  This looks to be the same individual pig though based on the data.

```{r}
longdat2 = longdat[!(pigID == "txcamp20154" & datetime < exdate), ]

collarDur3 = longdat2[, list(mindate=min(datetime), maxdate=max(datetime)), by=pigID]
ggplot(data=collarDur3) + geom_linerange(aes(x=pigID, ymin=mindate, ymax=maxdate)) + 
          theme(axis.text.x = element_text(angle = 90, hjust = 1,  size=10)) + 
          scale_y_datetime(breaks = seq(min(collarDur3$mindate), max(collarDur3$maxdate), by="month"))
```

A total of 26 pigs to consider

```{r}
for(pid in unique(longdat2$pigID)){
  tp = longdat2[pigID == pid, ]
  # plot(tp$datetime, type="l")
}

longdat2[, list(maxdelta=max(diff(datetime)), mindelta=min(diff(datetime)), meddelta=median(diff(datetime))), by=pigID]
```

The largest time gap we have is around 24 hours. It might be useful to clean that data further, but for now we will use imputation to account for the uncertainty around these trajectories.  Will be important to assess the sensitivity of the analysis to some of these gaps.

## Step 1: Load in and format the necessary covariate data

**Covariates to use**

1. Forest cover (binary)
2. Elevation (gradient)
3. Temperature (time-varying covariate)
4. NDVI/EVI forest cover

```{r}
source("pigfxns.R")
pig1 = longdat2[pigID == "txcamp20127"]
buffer = 0.005
extobj = extent(min(pig1$longitude) - buffer, max(pig1$longitude) + buffer, min(pig1$latitude) - buffer, max(pig1$latitude) + buffer)

loc_stack = process_covariates(c("temperature", "croplayer", "ndvi"), "txcamp", extobj, min(pig1$datetime), max(pig1$datetime), ext="loc")
grad_stack = process_covariates(c("elevation","ndvi"), "txcamp", extobj, min(pig1$datetime), max(pig1$datetime), ext="grad")

# Ensure projections are the same
locnames = names(loc_stack)
loc_stackproj = stack(lapply(loc_stack, function(x) projectRaster(x, loc_stack[['croplayer_loc']], method="ngb")))
grad_stackproj = stack(lapply(grad_stack, function(x) projectRaster(x, loc_stack[['croplayer_loc']], method="bilinear")))
```

## Step 2: Fit a continuous time basis functions and get the continuous path

Three options here:

1. Use simple interpolation
  - **Advantage**: Because this approach assumes perfect data, we will recover the observed locations when we ``simulate'' the the movement path.
                   Fast and easy to calculate trajectories.
  - **Disadvatanges**:  Does not propoerly account for uncertainty in movement.  Particularly if there is a long time (e.g. 3 hours) between fixes,
                   this approach just interpolates a straight-line between points which might be very wrong.
2. Use a b-spline approach in a frequentist framework
  - **Advantages**: Captures uncertainty in movement path and can propagate this uncertainty through to parameter estimates of resource selection. 
  - **Disadvantages**: While quite fast for small to medium data, both fitting and uncertainty estimation are pretty slow for large data (e.g. 100,000 predictions).
2. Use a b-spline approach in a Bayesian framework (`mcmc.fmove`)
  - **Advantages**:  Same advantages as above. But also regularlizations is baked into this approach which is quite useful.
  - **Disadvatanges**:  Will need to check convergence of MCMC chains for each site, which could be time consuming across populations. Moreover, long MCMC runs may take awhile, but preliminary simulations suggest that these might not be too much slower than the frequentist fit (seems strange...).


```{r}
source("pigfxns.R")

dat  = pig1[1:1000, list(x=longitude, y=latitude, datetime=datetime)]
predinterp = continuous_path(dat, "15 mins", "interp")

plot(dat[, list(x, y)], type="b")
points(predinterp$paths[[1]], cex=0.1, col="red")

predbfreq = continuous_path(dat, "15 mins", "bspline_freq", impute=3, df=500, sigma.fixed = 0.001)

plot(dat[, list(x, y)], type="b")
points(predbfreq$paths[[1]], type="l", col="red")
points(predbfreq$paths[[2]], type="l", col="blue")
points(predbfreq$paths[[3]], type="l", col="green")

predbbayes = continuous_path(dat, "15 mins", "bspline_bayes", impute=3, sigma.fixed = NA, df=500)

plot(dat[, list(x, y)], type="b")
points(predbbayes$paths[[1]], type="l", col="red")
points(predbbayes$paths[[2]], type="l", col="blue")
points(predbbayes$paths[[3]], type="l", col="green")
```


## Step 3: Fit the CTMC model using the ctmcmove package

Looking at three primary covariates in this analysis:

1. Temperature (study-level, but time varying)
2. Elevation (cell-level)
3. Forest cover (cell-level)

```{r}
source("pigfxns.R")
dat = pig1[1:1000, list(x=longitude, y=latitude, datetime=datetime)]
glm_data = fit_ctmcmodel(dat, pig1$pigID[1], loc_stackproj, grad_stackproj, method="interp", impute=4,
                         buffer=0.009, mc.cores=4, df=100, sigma.fixed=0.001)
glm_data = as.data.table(glm_data)
```

## Step 4: Look at how resources effect movement

```{r}

# Format various time-dependent measures
glm_data$datetime = as.POSIXct(glm_data$t, origin = '1970-01-01', tz = 'GMT')
glm_data$hour = hour(glm_data$datetime)
glm_data$month = month(glm_data$datetime)
glm_data$year = year(glm_data$datetime)
glm_data$monthyear = paste(glm_data$month, glm_data$year, sep="_")

# Convert temperature data
unqtemp = t(glm_data[, unique(.SD), .SDcols = names(glm_data) %like% "temperature"])
monthyear = sapply(strsplit(rownames(unqtemp), "_"), function(x) paste(x[[2]], x[[3]], sep="_"))
tempdt = data.table(monthyear=monthyear, temperature=unqtemp[, 1])

glm_datatemp = merge(glm_data, tempdt, by="monthyear")

fits = list()
for(i in 1:1){
  fits[[i]] = glm(z ~ croplayer_loc + scale(crw) + scale(elevation_grad) + scale(ndvi_3_2016_grad) + scale(ndvi_3_2016_loc),
              family="poisson", offset=log(tau), data=glm_datatemp[imputeID == i, ])
}

lapply(fits, coef)
```

Depending on the scale of the grid cells and the uncertainty in the basis function estimate of movement, we can really change our results regarding the significance of location predictors.  This makes a lot of sense.

## Step 5: Parallelize across individual pigs in txcamp

```{r}
library(parallel)
source("pigfxns.R")

ppigs = function(i, allpigs, numpoints, buffer){
  
  unqpig = unique(allpigs$pigID)
  pigdata = allpigs[pigID == unqpig[i], ]
  
  extobj = extent(min(pigdata$longitude) - buffer, max(pigdata$longitude) + buffer, 
                  min(pigdata$latitude) - buffer, max(pigdata$latitude) + buffer)
  
  loc_stack = process_covariates(c("temperature", "croplayer"), "txcamp", extobj, 
                                 min(allpigs$datetime), max(allpigs$datetime), ext="loc")
  grad_stack = process_covariates(c("elevation"), "txcamp", extobj, 
                                 min(allpigs$datetime), max(allpigs$datetime), ext="grad")
  
  # Ensure projections are the same
  locnames = names(loc_stack)
  loc_stackproj = stack(lapply(loc_stack, function(x) projectRaster(x, loc_stack[['croplayer_loc']],
                                                                                method="ngb")))
  grad_stackproj = stack(lapply(grad_stack, function(x) projectRaster(x, loc_stack[['croplayer_loc']],
                                                                                method="bilinear")))
  
  pigdata = pigdata[, list(x=longitude, y=latitude, datetime=datetime)]
  tglmdat = fit_ctmcmodel(pigdata[1:numpoints, ], unqpig[i], loc_stackproj, grad_stackproj, method="interp", impute=1,
                          buffer=0.002, mc.cores=1)
  
  # NEED TO MATCH COLUMNS
  
  return(tglmdat)
}

unqpig = unique(longdat2$pigID)
allglmdat = mclapply(1:length(unqpig), ppigs, longdat2, 100, 0.002, mc.cores=4)

```

```{r}
glmdat = as.data.table(do.call(rbind, allglmdat))

# Format various time-dependent measures
glmdat$datetime = as.POSIXct(glmdat$t, origin = '1970-01-01', tz = 'GMT')
glmdat$hour = hour(glmdat$datetime)
glmdat$month = month(glmdat$datetime)
glmdat$year = year(glmdat$datetime)
glmdat$monthyear = paste(glmdat$month, glmdat$year, sep="_")

# Convert temperature data
unqtemp = t(glmdat[, unique(.SD), .SDcols = names(glmdat) %like% "temperature"])
monthyear = sapply(strsplit(rownames(unqtemp), "_"), function(x) paste(x[[2]], x[[3]], sep="_"))
tempdt = data.table(monthyear=monthyear, temperature=unqtemp[, 1])

glmdat_temp = merge(glmdat, tempdt, by="monthyear")

```

```{r}
library(lme4)
fit = glmer(z ~ croplayer_loc + elevation_grad + (croplayer_loc + elevation_grad | pigID) + crw,
              family="poisson", offset=log(tau), data=glmdat_temp)
```

```{r}
summary(fit)
boxplot(coef(fit)$pigID[, "croplayer_loc"])
```
